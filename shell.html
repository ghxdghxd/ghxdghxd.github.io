<div class="header">
  <h1 class="page-title">
    <a class="icon circle-icon glyphicon glyphicon-chevron-left trigger-message-close"></a>
    shell
  </h1>
  <div class="details">
    <div class="left">
      10月 12, 2016
      <span> | </span> <a href="/category/xiao-chao-su-cha.html">小抄速查</a>
    </div>
    <div class="right">
      <a class="fa fa-tag" href="/tag/shell.html">shell</a>
    </div>
  </div>
</div>
<div id="message-nano-wrapper" class="nano">
  <div class="nano-content">
    <ul class="message-container">
        <div class="message">
          <h1>常用命令</h1>
<div class="highlight"><pre><span class="code-line"><span></span>0表示标准输入</span>
<span class="code-line">1表示标准输出</span>
<span class="code-line">2表示标准错误输出</span>
<span class="code-line">&gt; 默认为标准输出重定向，与 <span class="m">1</span>&gt; 相同</span>
<span class="code-line"><span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span> 意思是把 标准错误输出 重定向到 标准输出.</span>
<span class="code-line"><span class="p">&amp;</span>&gt;file 意思是把 标准输出 和 标准错误输出 都重定向到文件file中</span>
</pre></div>


<h2>awk</h2>
<div class="highlight"><pre><span class="code-line"><span></span><span class="nv">$0</span>~/aaa/表示0包括aaa</span>
<span class="code-line">split <span class="o">(</span>string, array, field separator<span class="o">)</span></span>
<span class="code-line">split <span class="o">(</span>string, array<span class="o">)</span>  <span class="se">\-</span>-<span class="p">&amp;</span>gt<span class="p">;</span>如果第三个参数没有提供，awk就默认使用当前FS值。</span>
<span class="code-line">substr<span class="o">(</span>s,p<span class="o">)</span> 返回字符串s中从p开始的后缀部分</span>
<span class="code-line">substr<span class="o">(</span>s,p,n<span class="o">)</span> 返回字符串s中从p开始长度为n的后缀部分</span>
<span class="code-line">length函数返回整个记录中的字符数。</span>
<span class="code-line">gsub<span class="o">(</span>regular expression, subsitution string, target string<span class="o">)</span><span class="p">;</span></span>
<span class="code-line">index<span class="o">(</span>a,b<span class="o">)</span>, r返回b中a的位置，没有返回0</span>
<span class="code-line"><span class="k">for</span><span class="o">(</span><span class="nv">i</span><span class="o">=</span><span class="m">1</span><span class="p">;</span>i<span class="p">&amp;</span>lt<span class="p">;</span><span class="o">=</span>length<span class="o">(</span>a<span class="o">)</span><span class="p">;</span>i++<span class="o">)</span></span>
</pre></div>


<h3>awk,getline,用于获得下一行</h3>
<div class="highlight"><pre><span class="code-line"><span></span>输出奇数，</span>
<span class="code-line">seq <span class="m">10</span> <span class="p">|</span> awk <span class="s1">&#39;{print $0;getline}&#39;</span></span>
<span class="code-line"><span class="m">1</span></span>
<span class="code-line"><span class="m">3</span></span>
<span class="code-line"><span class="m">5</span></span>
<span class="code-line"><span class="m">7</span></span>
<span class="code-line"><span class="m">9</span></span>
<span class="code-line">输出偶数</span>
<span class="code-line">seq <span class="m">10</span> <span class="p">|</span> awk <span class="s1">&#39;{getline;print $0}&#39;</span></span>
<span class="code-line"><span class="m">2</span></span>
<span class="code-line"><span class="m">4</span></span>
<span class="code-line"><span class="m">6</span></span>
<span class="code-line"><span class="m">8</span></span>
<span class="code-line"><span class="m">10</span></span>
<span class="code-line"></span>
<span class="code-line">输出三行,如果后面没有足够的行，则输出最后一行</span>
<span class="code-line">seq <span class="m">10</span> <span class="p">|</span> awk <span class="s1">&#39;{getline;getline;print $0}&#39;</span></span>
<span class="code-line"><span class="m">3</span></span>
<span class="code-line"><span class="m">6</span></span>
<span class="code-line"><span class="m">9</span></span>
<span class="code-line"><span class="m">10</span></span>
<span class="code-line">获得shell命令的结果</span>
<span class="code-line">注: 如果cmd出错,则res为上一行的结果，因此前面添加**res<span class="o">=</span><span class="se">\&quot;\&quot;</span>**</span>
<span class="code-line">    出现awk <span class="o">(</span>Too many open files<span class="o">)</span>, 需要 **close<span class="o">(</span>cmd<span class="o">)</span>**</span>
<span class="code-line"></span>
<span class="code-line">awk <span class="s1">&#39;{cmd=&quot;echo&quot;$0; res=&quot;&quot;;</span></span>
<span class="code-line"><span class="s1">    cmd|getline res;</span></span>
<span class="code-line"><span class="s1">    print $res;</span></span>
<span class="code-line"><span class="s1">    close (cmd)}&#39;</span> file</span>
</pre></div>


<h2>sed</h2>
<div class="highlight"><pre><span class="code-line"><span></span>sed -n <span class="s1">&#39;/A/,/B/p&#39;</span>  匹配A的行与匹配B的行之间的内容</span>
<span class="code-line">sed -n <span class="s1">&#39;2p,4,5p&#39;</span> 输出2 <span class="m">4</span>,5 行</span>
<span class="code-line">sed <span class="s2">&quot;s/</span><span class="nv">$a</span><span class="s2">/</span><span class="nv">$b</span><span class="s2">/g&quot;</span> 变量替换</span>
</pre></div>


<h2>grep</h2>
<div class="highlight"><pre><span class="code-line"><span></span>cat file  <span class="p">|</span> grep <span class="s1">&#39;[:space:]*#&#39;</span>匹配空格</span>
<span class="code-line">grep -P <span class="s1">&#39;\t&#39;</span> 匹配制表符</span>
<span class="code-line">grep -E <span class="s2">&quot;abc|123&quot;</span> myfile -n 两个关键词</span>
</pre></div>


<h2>ln</h2>
<div class="highlight"><pre><span class="code-line"><span></span>ln -s 源文件 目标文件</span>
</pre></div>


<h2>paste</h2>
<div class="highlight"><pre><span class="code-line"><span></span>paste -s -d <span class="s1">&#39;\t&#39;</span>  多行合并成一行</span>
</pre></div>


<h2>tr</h2>
<div class="highlight"><pre><span class="code-line"><span></span>tr -s <span class="s1">&#39; &#39;</span> 多个空格变一个</span>
</pre></div>


<h2>sort</h2>
<div class="highlight"><pre><span class="code-line"><span></span>sort -V 按染色体排序 <span class="m">1</span>，2，3，，，，X，Y</span>
</pre></div>


<h2>unzip</h2>
<div class="highlight"><pre><span class="code-line"><span></span>unzip -l zipfile   查看list</span>
<span class="code-line">unzip -p zipfile <span class="s2">&quot;*/getfile&quot;</span> <span class="p">|</span>less   查看指定文件</span>
<span class="code-line">unzip -d outdir    指定输出目录</span>
</pre></div>


<h2>gzip</h2>
<div class="highlight"><pre><span class="code-line"><span></span>gzip -t/--test 检测gz文件是否有错误</span>
</pre></div>


<h2>find</h2>
<p>按大小
find . -size +50M</p>
<p>find 按文件修改时间查找文件</p>
<p>----(+n)---------|------------(n)--------------|---------(-n)----
   (n+1)<em>24H前   |    (n+1)</em>24H ~ n<em>24H之间  |  n</em>24H以内</p>
<p>-ctime -n    查找距现在 n<em>24H 内修改过的文件
-ctime n    查找距现在 n</em>24H 前, (n+1)<em>24H 内修改过的文件
-ctime +n    查找距现在 (n+1)</em>24H 前修改过的文件</p>
<p>[a|c|m]min    [最后访问|最后状态修改|最后内容修改]min
[a|c|m]time    [最后访问|最后状态修改|最后内容修改]time</p>
<p>linux 文件的几种时间 (以 find 为例):
atime 最后一次访问时间, 如 ls, more 等, 但 chmod, chown, ls, stat 等不会修改些时间, 使用 ls -utl 可以按此时间顺序查看;
ctime 最后一次状态修改时间, 如 chmod, chown 等状态时间改变但修改时间不会改变, 使用 stat file 可以查看;
mtime 最后一次内容修改时间, 如 vi 保存后等, 修改时间发生改变的话, atime 和 ctime 也相应跟着发生改变.</p>
<p>注意: linux 里是不会记录文件的创建时间的, 除非这个文件自创建以来没有发生改变, 那么它的创建时间就是它的最后一次修改时间.</p>
<p><em>ls -lt    ./  按修改时间顺序查看
</em>ls -lut ./ 按访问时间顺序查看</p>
<p>[acm]time  计量单位是天，即24H
[acm]min    计量单位是分钟
find ./ -mtime 0  #查找一天内修改的文件
find ./ -mtime -2 #查找2天内修改的文件，多了一个减号
find ./ -mmin  -10  #查找距离现在10分钟内修改的文件</p>
<h2>计算 expr</h2>
<div class="highlight"><pre><span class="code-line"><span></span>expr <span class="m">1</span> + <span class="m">1</span></span>
<span class="code-line">expr</span>
</pre></div>


<h2>查看网速sar</h2>
<div class="highlight"><pre><span class="code-line"><span></span>sar -n DEV <span class="m">1</span> <span class="m">100</span></span>
</pre></div>


<h2>sudo !!命令</h2>
<p>没有特定输入sudo命令而运行，将给出没有权限的错误。那么，你不需要重写整个命令，仅仅输入'!!'就可以抓取最后的命令。</p>
<h2>Ctrl+x+e命令</h2>
<p>这个命令对于管理员和开发者非常有用。为了使每天的任务自动化，管理员需要通过输入vi、vim、nano等打开编辑器。</p>
<p>仅仅从命令行快速的敲击“Ctrl-x-e”，就可以在编辑器中开始工作了。</p>
<h2>nl命令</h2>
<p>“nl命令”添加文件的行数。</p>
<h2>shuf n1</h2>
<p>随机从一个文件或文件夹中选择行/文件/文件夹。首先使用ls命令来显示文件夹的内容。</p>
<h2>数组</h2>
<div class="highlight"><pre><span class="code-line"><span></span><span class="nv">array</span><span class="o">=(</span><span class="sb">`</span>cat test.txt<span class="p">|</span>cut -f <span class="m">1</span><span class="sb">`</span><span class="o">)</span></span>
<span class="code-line"><span class="si">${</span><span class="nv">array</span><span class="p">[@]</span><span class="si">}</span> <span class="c1"># 数组全部</span></span>
<span class="code-line"><span class="si">${#</span><span class="nv">array</span><span class="p">[@]</span><span class="si">}</span> <span class="c1"># 数组长度</span></span>
<span class="code-line"><span class="si">${</span><span class="nv">array</span><span class="p">[0]</span><span class="si">}</span> <span class="c1"># 数组元素 0 1 2</span></span>
</pre></div>
        </div>
        <!-- <div class="tool-box">
          <a href="#" class="circle-icon small glyphicon glyphicon-share-alt"></a>
          <a href="#" class="circle-icon small red-hover glyphicon glyphicon-remove"></a>
          <a href="#" class="circle-icon small red-hover glyphicon glyphicon-flag"></a>
        </div> -->
    </ul>
  </div>
</div>

<script>
  $('.nano').overlayScrollbars({
    scrollbars: {
      autoHide: "leave",
    }
  });
  $('.trigger-message-close').on('click', function () {
    $('body').removeClass('show-message');
    $('#main .message-list li').removeClass('active');
    messageIsOpen = false;
    $('body').removeClass('show-main-overlay');
  });
  $('#message .header .left a').on('click', function (e) {
    e.preventDefault();
    helper.setQuery().clearRefinements().addDisjunctiveFacetRefinement("category", e.target.text).search();
    
  });
  $('#message .header .right a').on('click', function (e) {
    e.preventDefault();
    helper.setQuery().clearRefinements().addFacetRefinement("tags", e.target.text).search();
  });
</script>