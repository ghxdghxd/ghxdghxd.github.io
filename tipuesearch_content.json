{"pages":[{"title":"About","text":"","tags":"pages","url":"https://ghxdghxd.github.io/pages/about.html"},{"title":"git submodule的用法","text":"常用命令 git clone <repository> --recursive 递归的方式克隆整个项目 git submodule add <repository><path> 添加子模块 git submodule init 初始化子模块 git submodule update 更新子模块 git submodule foreach git pull 拉取所有子模块 如何使用 1. 创建带子模块的版本库 例如我们要创建如下结构的项目 project | --moduleA | --readme.txt 创建project版本库，并提交readme.txt文件 git init --bare project.git git clone project.git project1cd project1 echo \"This is a project.\" > readme.txt git add . git commit -m \"add readme.txt\" git push origin master cd .. 创建moduleA版本库，并提交a.txt文件 git init --bare moduleA.git git clone moduleA.git moduleA1 cd moduleA1 echo \"This is a submodule.\" > a.txt git add . git commit -m \"add a.txt\" git push origin master cd .. 在project项目中引入子模块moduleA，并提交子模块信息 cd project1 git submodule add ../moduleA.git moduleA git statusgit diff git add . git commit -m \"add submodule\" git push origin master cd .. 使用git status可以看到多了两个需要提交的文件，其中.gitmodules指定submodule的主要信息，包括子模块的路径和地址信息，moduleA指定了子模块的commit id，使用git diff可以看到这两项的内容。这里需要指出父项目的git并不会记录submodule的文件变动，它是按照commit id指定submodule的git header，所以.gitmodules和moduleA这两项是需要提交到父项目的远程仓库的。 On branch master Your branch is up-to-datewith 'origin/master' . Changes to be committed: ( use \"git reset HEAD ...\" to unstage ) new file: .gitmodules new file: moduleA 2. 克隆带子模块的版本库 方法一，先clone父项目，再初始化submodule，最后更新submodule，初始化只需要做一次，之后每次只需要直接update就可以了，需要注意submodule默认是不在任何分支上的，它指向父项目存储的submodule commit id。 git clone project.git project2 cd project2 git submodule init git submodule update cd .. 方法二，采用递归参数--recursive，需要注意同样submodule默认是不在任何分支上的，它指向父项目存储的submodule commit id。 git clone project.git project3 --recursive git submodule update --init --recursive 3. 修改子模块 修改子模块之后只对子模块的版本库产生影响，对父项目的版本库不会产生任何影响，如果父项目需要用到最新的子模块代码，我们需要更新父项目中submodule commit id，默认的我们使用git status就可以看到父项目中submodule commit id已经改变了，我们只需要再次提交就可以了。 cd project1/moduleA git branch echo \"This is a submodule.\" > b.txt git add . git commit -m \"add b.txt\" git push origin master cd .. git status git diff git add . git commit -m \"update submodule add b.txt\" git push origin master cd .. 4. 更新子模块 更新子模块的时候要注意子模块的分支默认不是master。 方法一，先pull父项目，然后执行 git submodule update ，注意moduleA的分支始终不是master。 cd project2 git pull git submodule update cd .. 方法二，先进入子模块，然后切换到需要的分支，这里是master分支，然后对子模块pull，这种方法会改变子模块的分支。 cd project3/moduleA git checkout master cd .. git submodule foreach git pull cd .. 5. 删除子模块 网上有好多用的是下面这种方法 git rm --cached moduleA rm -rf moduleA rm .gitmodules vim .git/config 删除submodule相关的内容，例如下面的内容 [ submodule \"moduleA\" ] url = /Users/nick/dev/nick-doc/testGitSubmodule/moduleA.git 然后提交到远程服务器 git add . git commit -m \"remove submodule\" 但是我自己本地实验的时候，发现用下面的方式也可以，服务器记录的是.gitmodules和moduleA，本地只要用git的删除命令删除moduleA，再用git status查看状态就会发现.gitmodules和moduleA这两项都已经改变了，至于.git/config，仍会记录submodule信息，但是本地使用也没发现有什么影响，如果重新从服务器克隆则.git/config中不会有submodule信息。 git rm moduleA git status git commit -m \"remove submodule\" git push origin master","tags":"工具包","url":"https://ghxdghxd.github.io/git-submodule.html"},{"title":"meta Analysis","text":"metafor document An Overview of Functions in the metafor Package {% pdf /documents/metafor_diagram.pdf %} pdf Viechtbauer gesis ma with metafor {% pdf /documents/talks_2016_viechtbauer_gesis_ma_with_metafor.pdf %} meta-analysis from odds ratios and confidence intervals using metafor dm <- structure ( list ( or = c ( 1.6 , 4.4 , 1.14 , 1.3 , 4.5 ), cill = c ( 1.2 , 2.9 , 0.45 , 0.6 , 3.2 ), ciul = c ( 2 , 6.9 , 2.86 , 2.7 , 6.1 )), . Names = c ( \"or\" , \"cill\" , \"ciul\" ), class = \"data.frame\" , row.names = c ( NA , -5L )) dm $ logor <- log ( dm $ or ) dm $ se1 <- ( log ( dm $ ciul ) - dm $ logor ) / 1.96 dm $ se2 <- ( dm $ logor - log ( dm $ cill )) / 1.96 dm $ se <- ( dm $ se1 + dm $ se2 ) / 2 library ( metafor ) dmres <- rma.uni ( yi = logor , sei = se , data = dm ) pdf () forest ( dmres , atransf = exp , showweights = T , mlab = \"rsid\" , slab = paste0 ( \"study\" , 1 : 5 )) dev.off ()","tags":"统计建模","url":"https://ghxdghxd.github.io/meta.html"},{"title":"archlinux安装与配置","text":"archlinux安装 # u盘启动后 # 连接网络 wifi-memu mount /dev/sda1 /mnt mkdir -p /mnt/home mount /dev/sda2 /mnt/home # 修改中国镜像源,如163.com vi /ect/pacman.d/mirrorlist pacstrap -i /mnt base base-devel #生成挂载文件fstab genfstab -U /mnt >> /mnt/etc/fstab archlinux 初步配置 #切换到archlinux arch-chroot /mnt /bin/bash 本地语言 vi /etc/locale.gen en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 #生效 locale-gen echo LANG = en_US.UTF-8 > /etc/locale.conf 时区 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # 或 # 按提示选择时区 tzselect #设置硬件时间 hwclock --systohc --utc grub引导系统 # 支持grub和EFI，可只选grup pacman -S grub efibootmgr grub-install --target = i386-pc --recheck --debug /dev/sda grup-mkconfig -o /boot/grub/grub.cfg 主机名 echo Garch >> /etc/hostname 网络配置 # 有线 systemctl enable dhcpcd.service # 无线 pacman -S iw wpa_supplicant dialog archlinux 配置 # 最小安装 # X桌面 pacman -S xorg-server # 显卡驱动 pacman -S xf86-video-ati pacman -S gnome gnome-tweak-tool pacman -S ttf-ubuntu # 可选","tags":"linux","url":"https://ghxdghxd.github.io/archlinux.html"},{"title":"docker安装与配置","text":"docker centos yum install docker tee /etc/yum.repos.d/docker.repo <<-'EOF' [dockerrepo] name=Docker Repository baseurl=https://yum.dockerproject.org/repo/main/centos/$releasever/ enabled=1 gpgcheck=1 gpgkey=https://yum.dockerproject.org/gpg EOF sed -i 's/other_args=\\\"\\\"/other_args=\\\"--graph=\\/share\\/apps\\/docker\\\"/g' /etc/sysconfig/docker for i in ` seq 1 8 ` ; do sudo scp /etc/yum.repos.d/docker.repo compute-0- $i :/etc/yum.repos.d/docker.repo done rocks run host \"yum install docker-engine\" rocks run host \"sed -i 's/other_args=\\\"\\\"/other_args=\\\"--graph=\\/share\\/apps\\/docker\\\"/g' /etc/sysconfig/docker\" 手动安装 # 手动安装centos6.5 一些需要安装 yum remove docker-engine cd /share/apps/until/docker/ yum install ./lua-filesystem-1.4.2-1.el6.x86_64.rpm yum install ./lxc-libs-1.0.11-1.el6.x86_64.rpm yum install ./lua-lxc-1.0.11-1.el6.x86_64.rpm yum install ./lua-alt-getopt-0.7.0-1.el6.noarch.rpm yum install ./lxc-1.0.11-1.el6.x86_64.rpm yum install ./docker-io-1.7.1-2.el6.x86_64.rpm wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo yum install device-mapper-event-libs service docker restart 安装错误 # 下面错误： /usr/bin/docker: relocation error: /usr/bin/docker: symbol dm_task_get_info_with_deferred_remove, version Base not defined in file libdevmapper.so.1.02 with link time reference fix: $ sudo yum install device-mapper-event-libs # 如果无法安装，重新更新 wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo # 然后再安装 docker应用 启动docker service docker start 添加用户 # 添加docker group： sudo groupadd docker # 将当前用户添加到docker组： sudo gpasswd -a ${ USER } docker # 重启docker服务： sudo service docker restart # 开机启动 chkconfig docker on 修改镜像和容器的存放路径 # /etc/sysconfig/docker加入： other_args = \"--graph=/data/docker\" # 停止Docker服务 service docker stop # 备份数据到新的存放路径 cp -rf /var/lib/docker /data/ # 修改备份/var/lib/docker路径 mv /var/lib/docker { ,.bak } # 启动Docker服务 service docker start # 测试Docker服务 docker info 用法 查看镜像 docker images 查找镜像 docker search 查看容器 docker ps -a 运行容器 docker run 将宿主机的/var/data挂载到容器中的/data: docker run -tdi -v /var/data:/data centos 如果ls: cannot open directory '.': Permission denied 修改/etc/sysconfig/docker，OPTIONS去掉--selinux-enabled","tags":"系统运维","url":"https://ghxdghxd.github.io/docker.html"},{"title":"网球拍的平衡点","text":"网球拍平衡点测量 这个是每份点得出来的公式（pts点，inch英寸） 1pts = 1/8 inch = 1/8 * 2.54cm = 0.3175cm 下面以标准拍子27英寸长度为例，换算出是68.5cm，那中心点就是34.25cm。然后假设你所量出平衡点到拍底的距离为h。 如果大于34.25，则是（h-34.25）/0.3175=T，就是T点头重 如果小于34.25，则是（34.25-h）/0.3175=T，就是T点头轻 图中可知，此时拍子是完全平衡状态，只需测量纸片到底盖的距离就可以了，按这个方法测量出我的拍子是32.34cm，套用公式: （34.25-32.34）÷0.3175=6.015，也就是6点头轻了！ 另附上球拍头轻和头重的优劣: 头轻拍更灵活易于控制，能让选手在网前有不错的表现，但是不能提供足够大的力量。头重拍，灵活性差，但能提供额外的力量更有利于底线的击球。一般专业的球拍都是头轻拍或者是平衡拍，因为这样更利于网前技术的发挥，而且专业球员都有很好的身体素质可以自身去发力。而初学拍比较多的是头重拍，这样能使初学者并不需要太多的发力就能击出力量较大的球。","tags":"兴趣爱好","url":"https://ghxdghxd.github.io/tennis-racquet.html"},{"title":"终端显示颜色","text":"echo显示带颜色，需要使用参数-e 格式如下: echo -e \"\\033[字背景颜色;文字颜色m字符串\\033[0m\" 例如: echo -e \"\\033[41;37m TonyZhang \\033[0m\" 其中41的位置代表底色, 37的位置是代表字的颜色 注： 1、字背景颜色和文字颜色之间是英文的\"\"\"\" 2、文字颜色后面有个m 3、字符串前后可以没有空格，如果有的话，输出也是同样有空格 下面看几个例子： echo -e \"\\033[30m 黑色字 \\033[0m\" echo -e \"\\033[31m 红色字 \\033[0m\" echo -e \"\\033[32m 绿色字 \\033[0m\" echo -e \"\\033[33m 黄色字 \\033[0m\" echo -e \"\\033[34m 蓝色字 \\033[0m\" echo -e \"\\033[35m 紫色字 \\033[0m\" echo -e \"\\033[36m 天蓝字 \\033[0m\" echo -e \"\\033[37m 白色字 \\033[0m\" echo -e \"\\033[40;37m 黑底白字 \\033[0m\" echo -e \"\\033[41;37m 红底白字 \\033[0m\" echo -e \"\\033[42;37m 绿底白字 \\033[0m\" echo -e \"\\033[43;37m 黄底白字 \\033[0m\" echo -e \"\\033[44;37m 蓝底白字 \\033[0m\" echo -e \"\\033[45;37m 紫底白字 \\033[0m\" echo -e \"\\033[46;37m 天蓝底白字 \\033[0m\" echo -e \"\\033[47;30m 白底黑字 \\033[0m\" 控制选项说明 ： 代码 作用 \\33[0m 关闭所有属性 \\33[1m 设置高亮度 \\33[4m 下划线 \\33[5m 闪烁 \\33[7m 反显 \\33[8m 消隐 \\33[30m -- \\33[37m 设置前景色 \\33[40m -- \\33[47m 设置背景色 \\33[nA 光标上移n行 \\33[nB 光标下移n行 \\33[nC 光标右移n行 \\33[nD 光标左移n行 \\33[y;xH 设置光标位置 \\33[2J 清屏 \\33[K 清除从光标到行尾的内容 \\33[s 保存光标位置 \\33[u 恢复光标位置 \\33[?25l 隐藏光标 \\33[?25h 显示光标","tags":"系统运维","url":"https://ghxdghxd.github.io/terminal-color.html"},{"title":"git的一般用法","text":"Git用法 1 建立仓库 远程 git remote add origin git@github.com:ghxdghxd $NAME .git 本地(初始化) git init 2 常用操作 拉取 git pull origin master 提交 git add *.py git commit -m \"message\" git push origin master/dev/develop 重命令与删除 git rm git mv 3 分支操作 主支 修补 发布 开发 功能 master hotfix release develop feature git branch /-a/r # 查看本地/全部/远程分支 git branch [ name ] # 建立分支 git branch -d [ name ] # 删除分支 git checkout -b [ name ] origin/develop # 建立并切换开发分支 git checkout [ name ] # 切换分支 git merge --no-ff [ name ] # 合并分支 git push origin dev:develop # 本地分支提交到远程 push命令用于将本地分支的更新，推送到远程主机。 git push <远程主机名> <本地分支名>:<远程分支名> git pull类似: git pull <远程分支>:<本地分支> 注意，分支推送顺序的写法是<来源地>:<目的地>， 所以git pull是<远程分支>:<本地分支>，而git push是<本地分支>:<远程分支>。 如果省略远程分支名，则表示将本地分支推送与之存在\"追踪关系\"的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。 git push origin master 上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。 git push origin :master 等同于 git push origin --delete master 上面命令表示删除origin主机的master分支。 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。 git push origin 上面命令表示，将当前分支推送到origin主机的对应分支。 如果当前分支只有一个追踪分支，那么主机名都可以省略。 git push 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。 git push -u origin master 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。 不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。 git config --global push.default matching 或者 git config --global push.default simple 还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。 git push --all origin 上面命令表示，将所有本地分支都推送到origin主机。 如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。 git push --force origin 上面命令使用–force选项，结果导致在远程主机产生一个\"非直进式\"的合并(non-fast-forward merge)。除非你很确定要这样做，否则应该尽量避免使用–force选项。 最后，git push不会推送标签(tag)，除非使用–tags选项。 git push origin --tags 中文乱码 git config --global core.quotepath false core.quotepath设为false的话，就不会对0x80以上的字符进行quote。中文显示正常。 gitignore忽略文件 1、配置语法： 以斜杠\"/\"开头表示目录； 以星号\"*\"通配多个字符； 以问号\"?\"通配单个字符 以方括号\"[]\"包含单个字符的匹配列表； 以叹号\"!\"表示不忽略(跟踪)匹配到的文件或目录； 此外，git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效； 2、示例： （1）规则：fd1/* 说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略； （2）规则：/fd1/* 说明：忽略根目录下的 /fd1/ 目录的全部内容； （3）规则： /* !.gitignore !/fw/bin/ !/fw/sf/ 说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录； warning: LF will be replaced by CRLF 在Windows环境下使用git进行add的时候，会提示如下warning: \"warning:LF will be replacee by CRLF\"。 这是因为在Windows中的换行符为CRLF，而在Linux中的换行符为LF。 在git创建的项目中换行符为LF，而执行git add时，系统会提示LF将被转换为CRLF。 解决的办法很简单，禁止git的自动转换即可。 git config --global core.autocrlf false //禁用自动转换","tags":"工具包","url":"https://ghxdghxd.github.io/git.html"},{"title":"之感","text":"话多应知，话少需明 前人看世界，后者品人生 棋逢对手 尽兴，将遇良才 榨干——干的漂亮 有点意思 一个男人在他该出现的时候，总也不出现，那有他和没有他，又有什么差别 数日子过年 在距今已经很久远的那一天，我们就约定好了重逢。我知道，我会找到你。《与之彼端，约定的地方》 人们的思维容易出现定势效应(set effect), 因为人们倾向于利用原有的方式解决问题，且会被困在这个思维里，无法跳出。如果 中途停下来处理其他事情，或中断了原来的情景 ，即使没有带着答案回来，也能在潜意识中明白一点，原来的思维方式可能是错的，或有新的思考方向。 这就是酝酿效应（incubation effect），指将问题搁置在一旁，能使得原有不合适的知识基础的活动性降低（减少思维定势），并采用新的方法考虑或解决问题。 定性，知事，选梦; 遇人，择城，终老。 今天是余生中最年轻的一天，想玩就玩去 爱情也许会过时，但\"爱你\"不会 此为月圆是月缺，彼是月缺为月圆，月圆盼月缺，月缺待月圆。 风起一阵知秋意， 时不时遇见，面对面错过。 三十而立，不是表面的成家或者立业，你立的，是成熟的思维模式，是独立而纵深的思考能力。 寄君一曲，不问曲终人聚散。有说顺其自然？如果有，那是否从此山水不相逢，莫道佳人长与短？ 什么是好工作：一不影响生活作息，二不影响家庭团聚，三能养家糊口。 28岁的你会不会被17岁的你嘲笑 只有当你拿起球拍，只有当你走进球场，你才会真正明白，为什么网球会如此受欢迎；只有当你背着行囊，只有当你远离一方，你才会真正明白，为什么过年如此备受期盼——数日子的日子 数日子的时间很慢，计时间的日子最快。看见的起点在远方，摸不着的终点在想… 活在梦想中 阳光不燥微风正好 我做好了要与你过一辈子的打算，也做好了你随时要走的准备 我却觉得这一大笔积分是我这辈子花的最值一次，因为我得到了钱买不来的东西……希望，从来都无法交易的东西 可否，少些理智，享受一下脱轨的惊喜 真正的离开，是没有告别的 最好的修养，是明知不问 健康大于一切 活得太过自私，想得太过周全，倒想糊涂一世，只在聪明一时，难在取舍","tags":"路由器","url":"https://ghxdghxd.github.io/the-sense.html"},{"title":"登录终端信息","text":"/etc/issue 在终端接口登录时候的提示字符,例如： [ root@linux ~ ] cat /etc/issue CentOS release 5 .6 ( Final ) Kernel \\r on an \\m issue内各代码说明： \\d 本地端时间的日期 \\l 显示第几个终端接口 \\m 显示硬件的等级 \\n 显示主机的网络名称 \\o 显示域名 \\r 操作系统的版本 \\t 显示本地端的时间 \\s 操作系统的名称 \\v 操作系统的版本 /etc/motd 登录后的公告消息, 比如：系统将会在某个时间进行维护 [ root@linux ~ ] vi /etc/motd Hello everyone, Our server will be maintained at please don ' t login at that time,thanks. 那么当用户登录的时候，就会显示设置的内容了。","tags":"系统运维","url":"https://ghxdghxd.github.io/terminal-announcement.html"},{"title":"R与Rstudio的安装过程（ubuntu）","text":"install R error File failed to load: /extensions/MathZoom.js export CFLAGS = \"-I/share/apps/R_depends/include\" export LDFLAGS = \"-L/share/apps/R_depends/lib\" ./configure ./configure --prefix = /opt/R-3.3.1 --enable-R-shlib --with-libpng --with-jpeglib --with-libtiff --with-x --with-tcltk 1. configure: error: No F77 compiler found sudo apt-get install gfortran 2. configure: error: --with-readline sudo apt-get install libreadline-dev 3. configure: error: --with-x=yes sudo apt-get install libxt-dev 4. checking whether zlib support suffices sudo apt-get install zlib1g-dev 5. checking whether bzip2 support suffices wget <http://www.bzip.org/1.0.6/bzip2-1.0.6.tar.gz> tar xvf bzip2-1.0.6.tar.gz cd bzip2-1.0.6 sudo make install # OR make -f Makefile-libbz2_so make clean make -n install PREFIX = $R_depends make install PREFIX = $R_depends install bzip2-lib 6. configure: error: \"liblzma sudo apt-get install liblzma-dev 7. configure: error: pcre >= 8.10 wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.39.tar.gz tar xvf pcre-8.39.tar.gz cd pcre-8.39 ./configure --enable-utf8 --prefix = $R_depends make & amp ; sudo make install 8. libcurl >= 7.28.0 library and headers are required with support for https wget https://www.openssl.org/source/openssl-1.1.0b.tar.gz tar xvf openssl-1.1.0b.tar.gz cd openssl-1.1.0b ./config make & amp ; sudo make install wget <https://curl.haxx.se/download/curl-7.50.3.tar.gz> tar xvf curl-7.50.3.tar.gz cd curl-7.50.3 ./configure --with-ssl = /usr/local/ssl/ make & amp ; sudo make install 9.configure: WARNING: you cannot build info or HTML versions of the R manuals sudo apt-get install texinfo 10. configure: WARNING: you cannot build PDF versions of the R manuals, configure: WARNING: you cannot build PDF versions of vignettes and help pages sudo apt-get install texlive 11. configure: WARNING: neither inconsolata.sty nor zi4.sty found: PDF vignettes and package manuals will not be rendered optimally wget <http://mirrors.ctan.org/install/fonts/inconsolata.tds.zip> sudo mv inconsolata.tds.zip /usr/share/texlive/texmf-dist/tex/latex cd /usr/share/texlive/texmf-dist/tex/latex unzip inconsolata.tds.zip sudo mktexlsr 12. 本版本不支持png sudo apt-get install libpng16-dev sudo apt-get install libtiff5-dev make 1./usr/local/lib/libbz2.a: 无法添加符号: 错误的值 rm /usr/local/lib/libbz2.a wget <http://zlib.net/zlib-1.2.8.tar.gz> tar xvf zlib-1.2.8.tar.gz cd zlib-1.2.8 CC = 'gcc -fPIC' ./configure ; make test sudo make install 2./usr/bin/ld: cannot find -lbz2 ; collect2: error: ld returned 1 exit status sudo apt-get install libbz2-dev # 会用到 make CC = 'gcc -fPIC' make install PREFIX = /software/packages make install 1.conftest.c:1:17: fatal error: jni.h cd R-3.3.1/doc wget <https://cran.r-project.org/doc/manuals/r-release/NEWS.pdf> install rstudio sudo apt-get install libjpeg62-dev sudo apt-get install libgstreamer0.10-0 sudo apt-get install libgstreamer-plugins-base0.10-0 export RSTUDIO_WHICH_R = \"/opt/R-3.3.1/bin/R\" 添加到/etc/profile或~/.profile run R Error in grid.Call(L_textBounds, as.graphicsAnnot(xlabel),xlabel),x x, x$y, :无法载入X11字面为2,大小为20的字形- -courier-%s-%s- - -%d- - - - - - - sudo apt-get install t1-xfree86-nonfree ttf-xfree86-nonfree ttf-xfree86-nonfree-syriac sudo apt-get install xfonts-75dpi sudo apt-get install xfonts-100dpi sudo apt-get install mesa-utils sudo apt-get install libxtst-dev using R 无法载入共享目标对象 stringi.so install.packages ( stringi ) R install.packages returns \"failed to create lock directory\" R CMD INSTALL --no-lock & lt ; pkg & gt ; # OR install.packages ( \"Rcpp\" , dependencies = TRUE, INSTALL_opts = c ( '\\--no-lock' )) An irrecoverable exception occurred. R is aborting now ... ERROR: loading failed R CMD INSTALL --no-test-load *packages* nlopt ./configure --enable-shared make make install","tags":"系统运维","url":"https://ghxdghxd.github.io/R-and-Rstudio.html"},{"title":"mount","text":"/etc/fstab 运维都知道的文件，若想把mount的disk和dir设置为每次开机自动加载，那么就要把相关信息写到这个文件中。当用\"mount -a\"命令自动mount的时候，也会去读这个文件。例如： LABEL = /hadoop/9 /hadoop/9 ext3 defaults,noatime,nodiratime,noauto 0 2 LABEL = /hadoop/10 /hadoop/10 ext3 defaults,noatime,nodiratime,noauto 0 2 /etc/mtab 这个文件主要是用mount命令的时候，系统根据实际mount的情况生成的数据，例如： /dev/sdb1 /hadoop/9 ext3 rw,noatime,nodiratime 0 0 /dev/sdc1 /hadoop/10 ext3 rw,noatime,nodiratime 0 0 /proc/mounts 这个文件是/proc/self/mounts的软链接，/proc下面的文件都是保存在内存中的，是内核自动生成的。所以/proc/mounts比/etc/mtab文件能更加真实的反映当前mount的情况 场景应用： 服务器中有一块盘因为有坏道，被umount了，通过\"df -h\"就查看不到这块盘的信息了。 或者你使用\"chmod 000 /dir\",把这块盘设为不能读不能写。 这时如果你管理了1000台服务器，你需要知道你的服务器中哪些盘是被umount了，你会怎么做？ 这里分享一个SHELL脚本，可以给你提供思路： function check_disks { for m in ` awk '$3~/ext3/ {printf\" %s \",$2}' /etc/fstab ` ; do fsdev = \"\" fsdev = ` awk -v m = $m '$2==m {print $1}' /proc/mounts ` ; if [ -z \" $fsdev \" ] ; then msg_ = \" $msg_ $m (u)\" else msg_ = \" $msg_ `awk -v m= $m ' $2 ==m { if ( $4 ~ /&#94;ro,/ ) {printf\" %s ( ro ) \", $2 } ; }' /proc/mounts`\" fi done if [ -z \" $msg_ \" ] ; then echo \"disks ok\" ; exit 0 else echo \" $msg_ \" ; exit 2 fi } 脚本首先通过比较/etc/fstab和/proc/mounts中的不同之处，得到被umount的盘，然后再把ro(read only)的盘也分析出来。","tags":"系统运维","url":"https://ghxdghxd.github.io/mount.html"}]}