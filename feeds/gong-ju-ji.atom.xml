<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>iKnowledgeBase - 工具集</title><link href="https://ghxdghxd.github.io/" rel="alternate"></link><link href="https://ghxdghxd.github.io/feeds/gong-ju-ji.atom.xml" rel="self"></link><id>https://ghxdghxd.github.io/</id><updated>2018-05-28T11:30:00+08:00</updated><entry><title>git submodule的用法</title><link href="https://ghxdghxd.github.io/git-submodule.html" rel="alternate"></link><published>2018-02-03T10:20:00+08:00</published><updated>2018-02-03T19:30:00+08:00</updated><author><name>JT Guo</name></author><id>tag:ghxdghxd.github.io,2018-02-03:/git-submodule.html</id><summary type="html">&lt;p&gt;参考 http://www.cnblogs.com/nicksheng/p/6201711.html， 用于项目 中的 项目&lt;/p&gt;</summary><content type="html">&lt;html&gt;&lt;body&gt;&lt;h1&gt;常用命令&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git clone &amp;lt;repository&amp;gt; --recursive 递归的方式克隆整个项目&lt;/span&gt;
&lt;span class="code-line"&gt;git submodule add &amp;lt;repository&amp;gt;&amp;lt;path&amp;gt; 添加子模块&lt;/span&gt;
&lt;span class="code-line"&gt;git submodule init 初始化子模块&lt;/span&gt;
&lt;span class="code-line"&gt;git submodule update 更新子模块&lt;/span&gt;
&lt;span class="code-line"&gt;git submodule foreach git pull 拉取所有子模块&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;如何使用&lt;/h2&gt;
&lt;h3&gt;1. 创建带子模块的版本库&lt;/h3&gt;
&lt;p&gt;例如我们要创建如下结构的项目&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;project&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;|&lt;/span&gt;--moduleA&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="p"&gt;|&lt;/span&gt;--readme.txt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建project版本库，并提交readme.txt文件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git init --bare project.git&lt;/span&gt;
&lt;span class="code-line"&gt;git clone project.git project1cd project1&lt;/span&gt;
&lt;span class="code-line"&gt;echo&lt;span class="s2"&gt;"This is a project."&lt;/span&gt; &amp;gt; readme.txt&lt;/span&gt;
&lt;span class="code-line"&gt;git add .&lt;/span&gt;
&lt;span class="code-line"&gt;git commit -m &lt;span class="s2"&gt;"add readme.txt"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;git push origin master&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; ..&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;!--more--&gt;
&lt;p&gt;创建moduleA版本库，并提交a.txt文件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git init --bare moduleA.git&lt;/span&gt;
&lt;span class="code-line"&gt;git clone moduleA.git moduleA1&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; moduleA1&lt;/span&gt;
&lt;span class="code-line"&gt;echo&lt;span class="s2"&gt;"This is a submodule."&lt;/span&gt; &amp;gt; a.txt&lt;/span&gt;
&lt;span class="code-line"&gt;git add .&lt;/span&gt;
&lt;span class="code-line"&gt;git commit -m &lt;span class="s2"&gt;"add a.txt"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;git push origin master&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; ..&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在project项目中引入子模块moduleA，并提交子模块信息&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; project1&lt;/span&gt;
&lt;span class="code-line"&gt;git submodule add ../moduleA.git moduleA&lt;/span&gt;
&lt;span class="code-line"&gt;git status&lt;/span&gt;
&lt;span class="code-line"&gt;git diff&lt;/span&gt;
&lt;span class="code-line"&gt;git add .&lt;/span&gt;
&lt;span class="code-line"&gt;git commit -m &lt;span class="s2"&gt;"add submodule"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;git push origin master&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; ..&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用git status可以看到多了两个需要提交的文件，其中.gitmodules指定submodule的主要信息，包括子模块的路径和地址信息，moduleA指定了子模块的commit id，使用git diff可以看到这两项的内容。这里需要指出父项目的git并不会记录submodule的文件变动，它是按照commit id指定submodule的git header，所以.gitmodules和moduleA这两项是需要提交到父项目的远程仓库的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;On branch master&lt;/span&gt;
&lt;span class="code-line"&gt;Your branch is up-to-datewith&lt;span class="s1"&gt;'origin/master'&lt;/span&gt;.&lt;/span&gt;
&lt;span class="code-line"&gt;Changes to be committed:  &lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;"git reset HEAD ..."&lt;/span&gt;to unstage&lt;span class="o"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    new file:   .gitmodules&lt;/span&gt;
&lt;span class="code-line"&gt;    new file:   moduleA&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2. 克隆带子模块的版本库&lt;/h3&gt;
&lt;p&gt;方法一，先clone父项目，再初始化submodule，最后更新submodule，初始化只需要做一次，之后每次只需要直接update就可以了，需要注意submodule默认是不在任何分支上的，它指向父项目存储的submodule commit id。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git clone project.git project2&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; project2&lt;/span&gt;
&lt;span class="code-line"&gt;git submodule init&lt;/span&gt;
&lt;span class="code-line"&gt;git submodule update&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; ..&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法二，采用递归参数--recursive，需要注意同样submodule默认是不在任何分支上的，它指向父项目存储的submodule commit id。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git clone project.git project3 --recursive&lt;/span&gt;
&lt;span class="code-line"&gt;git submodule update --init --recursive&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3. 修改子模块&lt;/h3&gt;
&lt;p&gt;修改子模块之后只对子模块的版本库产生影响，对父项目的版本库不会产生任何影响，如果父项目需要用到最新的子模块代码，我们需要更新父项目中submodule commit id，默认的我们使用git status就可以看到父项目中submodule commit id已经改变了，我们只需要再次提交就可以了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; project1/moduleA&lt;/span&gt;
&lt;span class="code-line"&gt;git branch&lt;/span&gt;
&lt;span class="code-line"&gt;echo&lt;span class="s2"&gt;"This is a submodule."&lt;/span&gt; &amp;gt; b.txt&lt;/span&gt;
&lt;span class="code-line"&gt;git add .&lt;/span&gt;
&lt;span class="code-line"&gt;git commit -m &lt;span class="s2"&gt;"add b.txt"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;git push origin master&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; ..&lt;/span&gt;
&lt;span class="code-line"&gt;git status&lt;/span&gt;
&lt;span class="code-line"&gt;git diff&lt;/span&gt;
&lt;span class="code-line"&gt;git add .&lt;/span&gt;
&lt;span class="code-line"&gt;git commit -m &lt;span class="s2"&gt;"update submodule add b.txt"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;git push origin master&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; ..&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4. 更新子模块&lt;/h3&gt;
&lt;p&gt;更新子模块的时候要注意子模块的分支默认不是master。
方法一，先pull父项目，然后执行&lt;code&gt;git submodule update&lt;/code&gt;，注意moduleA的分支始终不是master。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; project2&lt;/span&gt;
&lt;span class="code-line"&gt;git pull&lt;/span&gt;
&lt;span class="code-line"&gt;git submodule update&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; ..&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法二，先进入子模块，然后切换到需要的分支，这里是master分支，然后对子模块pull，这种方法会改变子模块的分支。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; project3/moduleA&lt;/span&gt;
&lt;span class="code-line"&gt;git checkout master&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; ..&lt;/span&gt;
&lt;span class="code-line"&gt;git submodule foreach git pull&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; ..&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5. 删除子模块&lt;/h3&gt;
&lt;p&gt;网上有好多用的是下面这种方法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git rm --cached moduleA&lt;/span&gt;
&lt;span class="code-line"&gt;rm -rf moduleA&lt;/span&gt;
&lt;span class="code-line"&gt;rm .gitmodules&lt;/span&gt;
&lt;span class="code-line"&gt;vim .git/config&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除submodule相关的内容，例如下面的内容&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;submodule &lt;span class="s2"&gt;"moduleA"&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;      &lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; /Users/nick/dev/nick-doc/testGitSubmodule/moduleA.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后提交到远程服务器&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git add .&lt;/span&gt;
&lt;span class="code-line"&gt;git commit -m&lt;span class="s2"&gt;"remove submodule"&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是我自己本地实验的时候，发现用下面的方式也可以，服务器记录的是.gitmodules和moduleA，本地只要用git的删除命令删除moduleA，再用git status查看状态就会发现.gitmodules和moduleA这两项都已经改变了，至于.git/config，仍会记录submodule信息，但是本地使用也没发现有什么影响，如果重新从服务器克隆则.git/config中不会有submodule信息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git rm moduleA&lt;/span&gt;
&lt;span class="code-line"&gt;git status&lt;/span&gt;
&lt;span class="code-line"&gt;git commit -m&lt;span class="s2"&gt;"remove submodule"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;git push origin master&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</content><category term="git"></category><category term="submodule"></category></entry><entry><title>git的一般用法</title><link href="https://ghxdghxd.github.io/git.html" rel="alternate"></link><published>2016-11-03T10:20:00+08:00</published><updated>2016-11-05T19:30:00+08:00</updated><author><name>JT Guo</name></author><id>tag:ghxdghxd.github.io,2016-11-03:/git.html</id><summary type="html">&lt;p&gt;git的一般用法&lt;/p&gt;</summary><content type="html">&lt;html&gt;&lt;body&gt;&lt;h1&gt;Git用法&lt;/h1&gt;
&lt;h2&gt;1 建立仓库&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;远程&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git remote add origin git@github.com:ghxdghxd&lt;span class="nv"&gt;$NAME&lt;/span&gt;.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;本地(初始化)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git init&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2 常用操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;拉取&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git pull origin master&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;提交&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git add *.py&lt;/span&gt;
&lt;span class="code-line"&gt;git commit -m &lt;span class="s2"&gt;"message"&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;git push origin master/dev/develop&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;!--more--&gt;
&lt;ul&gt;
&lt;li&gt;重命令与删除&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git rm&lt;/span&gt;
&lt;span class="code-line"&gt;git mv&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3 分支操作&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;主支&lt;/th&gt;
&lt;th align="center"&gt;修补&lt;/th&gt;
&lt;th align="center"&gt;发布&lt;/th&gt;
&lt;th align="center"&gt;开发&lt;/th&gt;
&lt;th align="center"&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;master&lt;/td&gt;
&lt;td align="center"&gt;hotfix&lt;/td&gt;
&lt;td align="center"&gt;release&lt;/td&gt;
&lt;td align="center"&gt;develop&lt;/td&gt;
&lt;td align="center"&gt;feature&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git branch  /-a/r       &lt;span class="c1"&gt;# 查看本地/全部/远程分支&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;git branch &lt;span class="o"&gt;[&lt;/span&gt;name&lt;span class="o"&gt;]&lt;/span&gt;       &lt;span class="c1"&gt;# 建立分支&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;git branch -d &lt;span class="o"&gt;[&lt;/span&gt;name&lt;span class="o"&gt;]&lt;/span&gt;    &lt;span class="c1"&gt;# 删除分支&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;git checkout -b &lt;span class="o"&gt;[&lt;/span&gt;name&lt;span class="o"&gt;]&lt;/span&gt; origin/develop   &lt;span class="c1"&gt;# 建立并切换开发分支&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;git checkout &lt;span class="o"&gt;[&lt;/span&gt;name&lt;span class="o"&gt;]&lt;/span&gt;                     &lt;span class="c1"&gt;# 切换分支&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;git merge --no-ff &lt;span class="o"&gt;[&lt;/span&gt;name&lt;span class="o"&gt;]&lt;/span&gt;                &lt;span class="c1"&gt;# 合并分支&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;git push origin dev:develop             &lt;span class="c1"&gt;# 本地分支提交到远程&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;push命令用于将本地分支的更新，推送到远程主机。&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt;:&amp;lt;远程分支名&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;git pull类似:
    git pull &amp;lt;远程分支&amp;gt;:&amp;lt;本地分支&amp;gt;&lt;/p&gt;
&lt;p&gt;注意，分支推送顺序的写法是&amp;lt;来源地&amp;gt;:&amp;lt;目的地&amp;gt;，
所以git pull是&amp;lt;远程分支&amp;gt;:&amp;lt;本地分支&amp;gt;，而git push是&amp;lt;本地分支&amp;gt;:&amp;lt;远程分支&amp;gt;。
如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git push origin master&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。&lt;/p&gt;
&lt;p&gt;如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git push origin :master&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等同于&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git push origin --delete master&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面命令表示删除origin主机的master分支。&lt;/p&gt;
&lt;p&gt;如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git push origin&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面命令表示，将当前分支推送到origin主机的对应分支。&lt;/p&gt;
&lt;p&gt;如果当前分支只有一个追踪分支，那么主机名都可以省略。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git push&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git push -u origin master&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。&lt;/p&gt;
&lt;p&gt;不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git config --global push.default matching&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git config --global push.default simple&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git push --all origin&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面命令表示，将所有本地分支都推送到origin主机。&lt;/p&gt;
&lt;p&gt;如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git push --force origin&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面命令使用–force选项，结果导致在远程主机产生一个”非直进式”的合并(non-fast-forward merge)。除非你很确定要这样做，否则应该尽量避免使用–force选项。&lt;/p&gt;
&lt;p&gt;最后，git push不会推送标签(tag)，除非使用–tags选项。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git push origin --tags&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;中文乱码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;    git config --global core.quotepath &lt;span class="nb"&gt;false&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;core.quotepath设为false的话，就不会对0x80以上的字符进行quote。中文显示正常。&lt;/p&gt;
&lt;h2&gt;gitignore忽略文件&lt;/h2&gt;
&lt;p&gt;1、配置语法：&lt;/p&gt;
&lt;p&gt;以斜杠“/”开头表示目录；&lt;/p&gt;
&lt;p&gt;以星号“*”通配多个字符；&lt;/p&gt;
&lt;p&gt;以问号“?”通配单个字符&lt;/p&gt;
&lt;p&gt;以方括号“[]”包含单个字符的匹配列表；&lt;/p&gt;
&lt;p&gt;以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；&lt;/p&gt;
&lt;p&gt;此外，git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；&lt;/p&gt;
&lt;p&gt;2、示例：&lt;/p&gt;
&lt;p&gt;（1）规则：fd1/*
　　　　  说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；&lt;/p&gt;
&lt;p&gt;（2）规则：/fd1/*
　　　　  说明：忽略根目录下的 /fd1/ 目录的全部内容；&lt;/p&gt;
&lt;p&gt;（3）规则：&lt;/p&gt;
&lt;p&gt;/*
!.gitignore
!/fw/bin/
!/fw/sf/&lt;/p&gt;
&lt;p&gt;说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；&lt;/p&gt;
&lt;h2&gt;warning: LF will be replaced by CRLF&lt;/h2&gt;
&lt;p&gt;在Windows环境下使用git进行add的时候，会提示如下warning: “warning:LF will be replacee by CRLF”。&lt;/p&gt;
&lt;p&gt;这是因为在Windows中的换行符为CRLF，而在Linux中的换行符为LF。
在git创建的项目中换行符为LF，而执行git add时，系统会提示LF将被转换为CRLF。
解决的办法很简单，禁止git的自动转换即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;git config --global core.autocrlf &lt;span class="nb"&gt;false&lt;/span&gt; //禁用自动转换&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</content><category term="git"></category><category term="command"></category></entry><entry><title>R</title><link href="https://ghxdghxd.github.io/R.html" rel="alternate"></link><published>2016-10-12T21:52:00+08:00</published><updated>2018-01-13T10:02:00+08:00</updated><author><name>JT Guo</name></author><id>tag:ghxdghxd.github.io,2016-10-12:/R.html</id><summary type="html">&lt;p&gt;R的常用命令&lt;/p&gt;</summary><content type="html">&lt;html&gt;&lt;body&gt;&lt;h1&gt;R的常用命令&lt;/h1&gt;
&lt;h2&gt;R&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;    动态生成变量，并赋值， &lt;span class="kp"&gt;assign&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;x&lt;span class="p"&gt;,&lt;/span&gt; value&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</content><category term="R"></category></entry><entry><title>计算机字符编码</title><link href="https://ghxdghxd.github.io/Unicode.html" rel="alternate"></link><published>2016-10-12T21:52:00+08:00</published><updated>2018-02-28T11:10:00+08:00</updated><author><name>JT Guo</name></author><id>tag:ghxdghxd.github.io,2016-10-12:/Unicode.html</id><summary type="html">&lt;p&gt;计算机字符编码&lt;/p&gt;</summary><content type="html">&lt;html&gt;&lt;body&gt;&lt;h1&gt;计算机系统通用的字符编码&lt;/h1&gt;
&lt;h2&gt;数据结构(字符)&lt;/h2&gt;
&lt;p&gt;在计算机内存中，统一使用Unicode编码；当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。&lt;br/&gt;
用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：&lt;/p&gt;
&lt;p&gt;![编码1]](../images/bianma-1.png)&lt;/p&gt;
&lt;p&gt;utf-8编码的文件在内存中是unicode编码显示&lt;/p&gt;
&lt;p&gt;浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：&lt;/p&gt;
&lt;p&gt;&lt;img alt="编码2" src="../images/bianma-2.png"/&gt;&lt;/p&gt;
&lt;p&gt;服务器把动态生成的Unicode内容转换为UTF-8再传输&lt;/p&gt;
&lt;p&gt;所以你看到很多网页的源码上会有类似&lt;meta charset="utf-8"/&gt;的信息，表示该网页正是用的UTF-8编码。（UTF-8编码没有字节序的问题）&lt;/p&gt;
&lt;h2&gt;字符转化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;序列化&lt;/strong&gt;: 将一个数据结构（unicode编码， utf-8等）转化为二进制的数据流。用于存储，或者发送给网络中的其它程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同的编码形成的二进制流不一样。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;反序列化&lt;/strong&gt;：与序列化相反，将二进制流重新恢复成更易于处理和阅读的数据结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;python中的编码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Python中一切都是对象（object）。&lt;/li&gt;
&lt;li&gt;与字符编码类型有关的对象有str和bytes。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;str对象存储的字符是UNICODE类型，bytes对象存储的字符就是一串byte。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;str u'字符串以u开头'&lt;blockquote&gt;
&lt;p&gt;str.encode后得到的是一个bytes对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;bytes b'字节以b开头'&lt;blockquote&gt;
&lt;p&gt;bytes.decode之后，得到的是一个str对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;decode的作用是将其他编码的字符串转换成unicode编码，如str1.decode('gb2312')，表示将gb2312编码的字符串str1转换成unicode编码&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</content><category term="Unicode"></category><category term="UTF-8"></category></entry><entry><title>pandas</title><link href="https://ghxdghxd.github.io/pandas.html" rel="alternate"></link><published>2016-10-12T21:52:00+08:00</published><updated>2018-03-20T13:21:00+08:00</updated><author><name>JT Guo</name></author><id>tag:ghxdghxd.github.io,2016-10-12:/pandas.html</id><summary type="html">&lt;p&gt;pandas的常用命令&lt;/p&gt;</summary><content type="html">&lt;html&gt;&lt;body&gt;&lt;h1&gt;常用&lt;/h1&gt;
&lt;h2&gt;read_csv&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_csv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sep&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\t&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 第一行不设为列名&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt; &lt;span class="n"&gt;bed_df&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_table&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dtype&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'object'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'chr'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'start'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'pos'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'ref'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'alt'&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt; &lt;span class="sb"&gt;``&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="c1"&gt;## cat 合并&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="sb"&gt;``&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;python&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;Series&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s1"&gt;'a'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'b'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'c'&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cat&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s1"&gt;'A'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'B'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'C'&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;sep&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;','&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;filter&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;mat[mat.index.map(lambda x:x in list)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;dataframe to list&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;mat.drop_duplicates().values.tolist()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;merge dataframe&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;pd.connect([mat1, mat2, mat3], axis=1)  #axis=1 cbind, asis=0 rbind&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;insert&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;mat.insert(0, 'date', date) # insert in 0 col&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;pandas错误&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;read_csv: C-engine CParserError: Error tokenizing data&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When using read_csv like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;df&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_pickle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'faulty_row.pkl'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_csv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'faulty_row.csv'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;encoding&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'utf8'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_csv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'faulty_row.csv'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;encoding&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'utf8'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You get the following exception:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;CParserError: Error tokenizing data. C error: Buffer overflow caught - possible malformed input file.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Solution 1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can read the CSV using the python engine then no exception is thrown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_csv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'faulty_row.csv'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;encoding&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'utf8'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;engine&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'python'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Solution 2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If your second-to-last line includes an '\r' break.
You can open in universal-new-line mode to solve the error.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_csv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'test.csv'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'rU'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;encoding&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'utf-8'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;engine&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'c'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</content><category term="python"></category><category term="pandas"></category></entry><entry><title>python</title><link href="https://ghxdghxd.github.io/python.html" rel="alternate"></link><published>2016-10-12T21:52:00+08:00</published><updated>2018-02-28T11:10:00+08:00</updated><author><name>JT Guo</name></author><id>tag:ghxdghxd.github.io,2016-10-12:/python.html</id><summary type="html">&lt;p&gt;python的常用命令&lt;/p&gt;</summary><content type="html">&lt;html&gt;&lt;body&gt;&lt;h1&gt;python优化&lt;/h1&gt;
&lt;h2&gt;做一个pythonic的人&lt;/h2&gt;
&lt;h3&gt;1. 枚举&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iterable&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2. python -m cProfile&lt;/h3&gt;
&lt;h3&gt;3. time -p bash test.sh/python test.py&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt;</content><category term="python"></category><category term="pandas"></category></entry><entry><title>shell</title><link href="https://ghxdghxd.github.io/shell.html" rel="alternate"></link><published>2016-10-12T21:52:00+08:00</published><updated>2018-05-28T11:30:00+08:00</updated><author><name>JT Guo</name></author><id>tag:ghxdghxd.github.io,2016-10-12:/shell.html</id><summary type="html">&lt;p&gt;shell的常用命令&lt;/p&gt;</summary><content type="html">&lt;html&gt;&lt;body&gt;&lt;h1&gt;常用命令&lt;/h1&gt;
&lt;h2&gt;awk&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nv"&gt;$0&lt;/span&gt;~/aaa/表示0包括aaa&lt;/span&gt;
&lt;span class="code-line"&gt;    split &lt;span class="o"&gt;(&lt;/span&gt;string, array, field separator&lt;span class="o"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    split &lt;span class="o"&gt;(&lt;/span&gt;string, array&lt;span class="o"&gt;)&lt;/span&gt;  &lt;span class="se"&gt;\-&lt;/span&gt;-&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;gt&lt;span class="p"&gt;;&lt;/span&gt;如果第三个参数没有提供，awk就默认使用当前FS值。&lt;/span&gt;
&lt;span class="code-line"&gt;    substr&lt;span class="o"&gt;(&lt;/span&gt;s,p&lt;span class="o"&gt;)&lt;/span&gt; 返回字符串s中从p开始的后缀部分&lt;/span&gt;
&lt;span class="code-line"&gt;    substr&lt;span class="o"&gt;(&lt;/span&gt;s,p,n&lt;span class="o"&gt;)&lt;/span&gt; 返回字符串s中从p开始长度为n的后缀部分&lt;/span&gt;
&lt;span class="code-line"&gt;    length函数返回整个记录中的字符数。&lt;/span&gt;
&lt;span class="code-line"&gt;    gsub&lt;span class="o"&gt;(&lt;/span&gt;regular expression, subsitution string, target string&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    index&lt;span class="o"&gt;(&lt;/span&gt;a,b&lt;span class="o"&gt;)&lt;/span&gt;, r返回b中a的位置，没有返回0&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;i&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;lt&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;length&lt;span class="o"&gt;(&lt;/span&gt;a&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;i++&lt;span class="o"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;awk,getline,用于获得下一行&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;输出奇数，&lt;/span&gt;
&lt;span class="code-line"&gt;seq &lt;span class="m"&gt;10&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;'{print $0;getline}'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="m"&gt;3&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="m"&gt;5&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="m"&gt;7&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="m"&gt;9&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;输出偶数&lt;/span&gt;
&lt;span class="code-line"&gt;seq &lt;span class="m"&gt;10&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;'{getline;print $0}'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="m"&gt;4&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="m"&gt;6&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="m"&gt;8&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="m"&gt;10&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;输出三行,如果后面没有足够的行，则输出最后一行&lt;/span&gt;
&lt;span class="code-line"&gt;seq &lt;span class="m"&gt;10&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;'{getline;getline;print $0}'&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="m"&gt;3&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="m"&gt;6&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="m"&gt;9&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="m"&gt;10&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;sed&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;    sed -n &lt;span class="s1"&gt;'/A/,/B/p'&lt;/span&gt;  匹配A的行与匹配B的行之间的内容&lt;/span&gt;
&lt;span class="code-line"&gt;    sed -n &lt;span class="s1"&gt;'2p,4,5p'&lt;/span&gt; 输出2 &lt;span class="m"&gt;4&lt;/span&gt;,5 行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;grep&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;    cat file  &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s1"&gt;'[:space:]*#'&lt;/span&gt;匹配空格&lt;/span&gt;
&lt;span class="code-line"&gt;    grep -P &lt;span class="s1"&gt;'\t'&lt;/span&gt; 匹配制表符&lt;/span&gt;
&lt;span class="code-line"&gt;    grep -E &lt;span class="s2"&gt;"abc|123"&lt;/span&gt; myfile -n 两个关键词&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;ln&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;    ln -s 源文件 目标文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;paste&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;    paste -s -d &lt;span class="s1"&gt;'\t'&lt;/span&gt;  多行合并成一行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;tr&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;tr -s &lt;span class="s1"&gt;' '&lt;/span&gt; 多个空格变一个&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;sort&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;    sort  -V 按染色体排序 &lt;span class="m"&gt;1&lt;/span&gt;，2，3，，，，X，Y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;unzip&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;    unzip -l zipfile   查看list&lt;/span&gt;
&lt;span class="code-line"&gt;    unzip -p zipfile &lt;span class="s2"&gt;"*/getfile"&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;less   查看指定文件&lt;/span&gt;
&lt;span class="code-line"&gt;    unzip -d outdir    指定输出目录&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;gzip&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;gzip -t/--test 检测gz文件是否有错误&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;计算 expr&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;    expr &lt;span class="m"&gt;1&lt;/span&gt; + &lt;span class="m"&gt;1&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    expr&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;查看网速sar&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;sar -n DEV &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="m"&gt;100&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;sudo !!命令&lt;/h2&gt;
&lt;p&gt;没有特定输入sudo命令而运行，将给出没有权限的错误。那么，你不需要重写整个命令，仅仅输入'!!'就可以抓取最后的命令。&lt;/p&gt;
&lt;h2&gt;Ctrl+x+e命令&lt;/h2&gt;
&lt;p&gt;这个命令对于管理员和开发者非常有用。为了使每天的任务自动化，管理员需要通过输入vi、vim、nano等打开编辑器。&lt;/p&gt;
&lt;p&gt;仅仅从命令行快速的敲击“Ctrl-x-e”，就可以在编辑器中开始工作了。&lt;/p&gt;
&lt;h2&gt;nl命令&lt;/h2&gt;
&lt;p&gt;“nl命令”添加文件的行数。&lt;/p&gt;
&lt;h2&gt;shuf n1&lt;/h2&gt;
&lt;p&gt;随机从一个文件或文件夹中选择行/文件/文件夹。首先使用ls命令来显示文件夹的内容。&lt;/p&gt;
&lt;h2&gt;数组&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;array&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;cat test.txt&lt;span class="p"&gt;|&lt;/span&gt;cut -f &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;# 数组全部&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="si"&gt;${#&lt;/span&gt;&lt;span class="nv"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[@]&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;# 数组长度&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[0]&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;# 数组元素 0 1 2&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</content><category term="shell"></category><category term="bash"></category></entry></feed>